<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>Babylon Template</title>

        <style>
            html,
            body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>

        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    </head>

    <body>

        <canvas id="renderCanvas" touch-action="none"></canvas> //touch-action="none" for best results from PEP

        <script>
            window.addEventListener('DOMContentLoaded', function () {
                // get the canvas DOM element
                var canvas = document.getElementById("renderCanvas");
                var engine = new BABYLON.Engine(canvas, true);

                // createScene function that creates and return the scene
                var createScene = function () {
                    var scene = new BABYLON.Scene(engine);
                    // create a basic BJS Scene object
                    var camera = new BABYLON.ArcRotateCamera("Camera", BABYLON.Tools.ToRadians(-120), BABYLON.Tools.ToRadians(80), 65, new BABYLON.Vector3(0, -15, 0), scene); camera.attachControl(canvas, false);
                    var assetsManager = new BABYLON.AssetsManager(scene);
                    var meshTask = assetsManager.addMeshTask("atom", "", "/", "atom.glb");

                    meshTask.onSuccess = function (task) {
                        task.loadedMeshes[0].position = BABYLON.Vector3.Zero();
                    }
                    meshTask.onError = function (task, message, exception) {
                        console.log(message, exception);
                    }
                    assetsManager.onTaskErrorObservable.add(function (task) {
                        console.log('task failed', task.errorObject.message, task.errorObject.exception);
                    });
                    assetsManager.onProgress = function (remainingCount, totalCount, lastFinishedTask) {
                        engine.loadingUIText = 'We are loading the scene. ' + remainingCount + ' out of ' + totalCount + ' items still need to be loaded.';
                    };

                    assetsManager.onFinish = function (tasks) {
                        engine.runRenderLoop(function () {
                            scene.render();
                        });
                    };
                    assetsManager.onTaskSuccessObservable.add(function (task) {
                        console.log('task successful', task)
                    });
                    assetsManager.load();
                    return scene;
                }

                var scene = createScene();
                engine.runRenderLoop(function () {
                    scene.render();
                });
                window.addEventListener('resize', function () {
                    engine.resize();
                });
            
        });

        </script>

    </body>

</html>